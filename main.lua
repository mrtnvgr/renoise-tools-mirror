
function selection_scope() -- creates a table indexing all selected note columns (+tracks) in an iteration-friendly structure
 local s, sel = renoise.song(), renoise.song().selection_in_pattern
 local sel_note_columns = { }
 for track = sel.start_track, sel.end_track do
  for note_column = 1, s:track(track).visible_note_columns do
   if track >= sel.start_track and track <= sel.end_track and not (track == sel.end_track and note_column > sel.end_column) and not (track == sel.start_track and note_column < sel.start_column) then
    if not sel_note_columns[track] then sel_note_columns[track] = {  } end
    table.insert(sel_note_columns[track], note_column)
   end
  end
 end
return sel_note_columns
end

function notes_in_selection(track, selected_columns) -- creates a table with relevant data on all notes found in selection on a track
 local s, sel = renoise.song(), renoise.song().selection_in_pattern
 local notes, note_number = { }, 0
 for i = sel.start_line, sel.end_line do
  for column in pairs(selected_columns) do
   local note = s:pattern(s.selected_pattern_index):track(track):line(i):note_column(selected_columns[column])  
   if note.note_value ~= 121 then
    note_number = note_number + 1
    notes[note_number] = { line = i, note_value = note.note_value, instrument_value = note.instrument_value, panning_value = note.panning_value, volume_value = note.volume_value, note_column = selected_columns[column]   } 
   end
  end
 end
 rprint(notes)
 return notes
end

function create_reposition_table(notes) -- calculate and add data on where each note should be moved, into the table generated by notes_in_selection()
 local s, sel = renoise.song(), renoise.song().selection_in_pattern
 if next(notes) ~= nil then
  local even_space_between_notes = (sel.end_line - sel.start_line + 1) * 256 / #notes
  notes[1].new_line, notes[1].new_dly = sel.start_line, 0
  for i, value in ipairs(notes) do
   if i > 1 then
    notes[i].new_line = math.floor( sel.start_line + ( ( ( i-1 ) * even_space_between_notes ) / 256 ) )
    local new_dly = ( ( (i - 1) * even_space_between_notes) / 256 ) % 1
    notes[i].new_dly = math.floor( new_dly * 256 + 0.5 )
   end
  end
 return notes
 end
end

function move_notes_in_track(reposition_table, track, columns) -- changes the pattern data in accordance with the info generated by create_reposition_table()
 local s, sel = renoise.song(), renoise.song().selection_in_pattern
 if reposition_table then
 for i = sel.start_line, sel.end_line do
  for column in ipairs(columns) do
  local note = s:pattern(s.selected_pattern_index):track(track):line(i):note_column(columns[column])  
  note.note_value = 121 note.delay_value = 0 note.instrument_value = 255 note.panning_value = 255 note.volume_value = 255 -- blanking note data on each line before updating it in accordance with the reposition_table
  for n in ipairs(reposition_table) do
   if i == reposition_table[n].new_line and reposition_table[n].note_column == columns[column] then
    note.note_value = reposition_table[n].note_value
    note.delay_value = reposition_table[n].new_dly
    if note.delay_value > 0 then
     s:track(track).delay_column_visible = true
    end
    note.instrument_value = reposition_table[n].instrument_value note.panning_value = reposition_table[n].panning_value note.volume_value = reposition_table[n].volume_value
   else
   end
  end
 end
 end end
end

function do_it() -- main function to be triggered
 local s, sel = renoise.song(), renoise.song().selection_in_pattern
 if sel then
  local selection_scope = selection_scope()
  for track in pairs(selection_scope) do
   move_notes_in_track(create_reposition_table(notes_in_selection(track, selection_scope[track])), track, selection_scope[track])
  end
 end
end

renoise.tool():add_menu_entry {
  name = "Pattern Editor:Selection:Place notes evenly",
  invoke = function() do_it() end
}

renoise.tool():add_keybinding {
  name = "Pattern Editor:Selection:Place notes evenly",
  invoke = function() do_it() end
}
